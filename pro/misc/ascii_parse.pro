pro ascii_parse,fmtline,colname,coltype,sep=sep,idict=idict,fdict=fdict,$
	ldict=ldict,sdict=sdict,templat=templat,$
	escape=escape,fold_case=fold_case,regex=regex, _extra=e
;+
;procedure	ascii_parse
;	parse an ascii format template to figure out how many
;	columns, of what type, are in the ascii file.
;
;syntax
;	ascii_parse,fmtline,colname,coltype,sep=sep,idict=idict,fdict=fdict,$
;	ldict=ldict,sdict=sdict,templat=templat,escape=escape,/fold_case,$
;	regex=regex,verbose=verbose
;
;parameters
;	fmtline	[INPUT; required] a line describing the columns expected
;		to be a SEP-separated list of column names and formats,
;		with each field in the form "NAME FORMAT_CODE"
;		* if NAME is missing, or is illegal, then "COL#" is assigned
;		  to be the column name
;		* if FORMAT_CODE is missing or ununderstandable, then some
;		  obvious cases such as 'RA', 'Dec', etc. are recognized
;		  as floats and the rest are taken to be strings.
;		* FORMAT_CODEs are:
;		  'b' for I*1
;		  'i' for I*2
;		  'l' for I*4
;		  'f' or 'r' for R*4
;		  'd' for R*8
;		  'a' or 's' for strings
;		* if array, will be concatenated
;	colname	[OUTPUT; required] column names derived from FMTLINE
;	coltype	[OUTPUT; required] column types derived from FMTLINE
;		* will be one of
;		  byte, integer, long, float, double, or char
;		* will be char by default
;
;keywords
;	sep	[INPUT] field separator, taken to be "|" by default
;	idict	[INPUT] user-defined array of column names that are
;		to be considered integers
;	fdict	[INPUT] user-defined array of column names that are
;		to be considered float
;	fdict	[INPUT] user-defined array of column names that are
;		to be considered long integers
;	sdict	[INPUT] user-defined array of column names that are
;		to be considered char
;		* IDICT, FDICT, LDICT, and SDICT override internal directory
;		* SDICT takes precedence over LDICT takes precedence
;		  over FDICT takes precedence over IDICT
;	templat	[OUTPUT] a structure of the same form as generated by
;		ASCII_TEMPLATE()
;	escape	[INPUT] passed straight to STRSPLIT with no checks
;	fold_case	[INPUT] passed straight to STRSPLIT with no checks
;	regex	[INPUT] passed straight to STRSPLIT with no checks
;	_extra	[INPUT ONLY] pass defined keywords to subroutines
;		STRSPLIT: ESCAPE, FOLD_CASE, REGEX
;		LEGALVAR: VERBOSE
;
;example
;	fmtline = 'InputRA | InputDec | offset | obsid | srcid | ra |'+$
;	  'dec | netB | error_netB | flag | x | y | error_x | error_y |'+$
;	  'srcB | bkgB | barea_ratio | mean_ea | mean_bk_ea | srcS |'+$
;	  'bkgS | srcH | bkgH | srcS1 | bkgS1 | srcS2 | bkgS2 |'
;	ascii_parse,fmtline,colname,coltype,fdict=['src[^i]','bkg']
;	for i=0,n_elements(colname)-1 do print,colname[i],':',coltype[i]
;
;subroutines
;	LEGALVAR
;
;history
;	vinay kashyap (Jun03)
;	added _EXTRA in call to LEGALVAR (VK; Jul03)
;	added keyword SDICT (VK; Aug03)
;	added keyword TEMPLAT (VK; Apr04)
;	added keyword LDICT (VK; May04)
;	added keywords ESCAPE, FOLD_CASE, and REGEX to catch and pass on
;	  to STRSPLIT, because somebody has rather inconveniently gone
;	  and changed the STRSPLIT call to STRICT_EXTRA from plain EXTRA
;	  in IDL 6.2 (VK; Apr06)
;-

;	usage
ok='ok' & np=n_params() & nf=n_elements(fmtline) & sz=size(fmtline,/type)
if np lt 3 then ok='Insufficient parameters' else $
 if nf eq 0 then ok='FMTLINE is undefined' else $
  if sz ne 7 then ok='FMTLINE must be a string'
if ok ne 'ok' then begin
  print,'Usage: ascii_parse,fmtline,colname,coltype,sep=sep,idict=idict,$'
  print,'       fdict=fdict,ldict=ldict,sdict=sdict,templat=templat,$'
  print,'       escape=escape,/fold_case,regex=regex,verbose=verbose'
  print,'  parse an ascii format template to figure out how many'
  print,'  columns, of what type, are in the ascii file'
  if np ne 0 then message,ok,/informational
  return
endif

;	learned words
dictb=	['byte']
dicti=	['integer','flag']
dictl=	['long','obsid']
dictf=	['float','ra','dec','deg','offset','offax','count',$
	'net','error','mag','^x','^y']
dictd=	['double','mean']
dicts=	['char','string','\!','@','#','\$','%','&','\*','\(','\)',$
	'\[','\]',':',';','\|','\\','\/',',','\{','\}','`','~','<','>']

;	separator
ss='|' & if keyword_set(sep) then ss=sep[0]

;	the format statement
if nf gt 1 then fmt=strjoin(fmtline,ss) else fmt=fmtline[0]

;	split into fields
flds=strsplit(fmt,ss,/extract, escape=escape,fold_case=fold_case,regex=regex)
nflds=n_elements(flds)

;	figure out column names and types
colname='COL'+strtrim(indgen(nflds),2) & coltype=strarr(nflds)+'char'
for i=0L,nflds-1L do begin
  cc=strsplit(flds[i],/extract) & ncc=n_elements(cc)
  ch=strlowcase(cc)
  if ncc eq 1 then begin	;(field is either COLNAME or COLTYPE
    if strlen(cc[0]) eq 1 then begin	;(field has to be COLTYPE
      if (ch[0] eq 'b') then coltype[i]='byte' else $
       if (ch[0] eq 'i') then coltype[i]='integer' else $
	if (ch[0] eq 'l') then coltype[i]='long' else $
	 if (ch[0] eq 'f') or (ch[0] eq 'r') then coltype[i]='float' else $
	  if (ch[0] eq 'd') then coltype[i]='double' else $
	   if (ch[0] eq 'a') or (ch[0] eq 's') then coltype[i]='char' else $
	    if legalvar(cc[0],_extra=e) eq 1 then colname[i]=cc[0]	;and naturally, coltype[i] would be char
    endif else begin	;strlen(CC))(field can be either COLNAME or COLTYPE
      if strpos(ch[0],'byte',0) ge 0 or strpos(ch[0],'i*1',0) ge 0 then coltype[i]='byte' else $
       if strpos(ch[0],'integer',0) ge 0 or strpos(ch[0],'fix',0) ge 0 or strpos(ch[0],'i*2',0) ge 0 then coltype[i]='integer' else $
        if strpos(ch[0],'long',0) ge 0 or strpos(ch[0],'i*4',0) ge 0 then coltype[i]='long' else $
         if strpos(ch[0],'float',0) ge 0 or strpos(ch[0],'real',0) ge 0 or strpos(ch[0],'r*4',0) ge 0 then coltype[i]='float' else $
          if strpos(ch[0],'double',0) ge 0 or strpos(ch[0],'r*8',0) ge 0 then coltype[i]='double' else $
	   if strpos(ch[0],'string',0) ge 0 or strpos(ch[0],'char',0) ge 0 then coltype[i]='char' else $
	    if legalvar(cc[0],_extra=e) eq 1 then colname[i]=cc[0]	;and naturally, coltype[i] would be char
    endelse				;strlen(CC))
  endif else begin			;NCC=1)(field is "COLNAME COLTYPE"
    if legalvar(cc[0],_extra=e) eq 1 then colname[i]=cc[0]
    c0=strmid(strtrim(ch[1],2),0,1) & c1=strtrim(ch[1],2)
    if c0 eq 'b' then coltype[i]='byte' else $
     if c0 eq 'i' then coltype[i]='integer' else $
      if c0 eq 'l' then coltype[i]='long' else $
       if c0 eq 'f' or ch[0] eq 'r' then coltype[i]='float' else $
	if c0 eq 'd' then coltype[i]='double' else $
	 if c0 eq 'a' or ch[0] eq 's' then coltype[i]='char'
    if strpos(c1,'byte',0) ge 0 or strpos(c1,'i*1',0) ge 0 then coltype[i]='byte' else $
     if strpos(c1,'integer',0) ge 0 or strpos(c1,'fix',0) ge 0 or strpos(c1,'i*2',0) ge 0 then coltype[i]='integer' else $
      if strpos(c1,'long',0) ge 0 or strpos(c1,'i*4',0) ge 0 then coltype[i]='long' else $
       if strpos(c1,'float',0) ge 0 or strpos(c1,'real',0) ge 0 or strpos(c1,'r*4',0) ge 0 then coltype[i]='float' else $
        if strpos(c1,'double',0) ge 0 or strpos(c1,'r*8',0) ge 0 then coltype[i]='double' else $
	 if strpos(c1,'string',0) ge 0 or strpos(c1,'char',0) ge 0 then coltype[i]='char'
  endelse				;NCC>1)
endfor

;	now override COLTYPE using internal dictionary
ms=n_elements(sdict)
ml=n_elements(ldict)
mf=n_elements(fdict)
mi=n_elements(idict)
for i=0L,nflds-1L do begin			;{for each column
  for j=0L,n_elements(dictb)-1L do $
    if stregex(colname[i],dictb[j],/boolean,/fold_case) then coltype[i]='byte'
  for j=0L,n_elements(dicti)-1L do $
    if stregex(colname[i],dicti[j],/boolean,/fold_case) then coltype[i]='integer'
  for j=0L,n_elements(dictl)-1L do $
    if stregex(colname[i],dictl[j],/boolean,/fold_case) then coltype[i]='long'
  for j=0L,n_elements(dictf)-1L do $
    if stregex(colname[i],dictf[j],/boolean,/fold_case) then coltype[i]='float'
  for j=0L,n_elements(dictd)-1L do $
    if stregex(colname[i],dictd[j],/boolean,/fold_case) then coltype[i]='double'
  for j=0L,n_elements(dicts)-1L do $
    if stregex(colname[i],dicts[j],/boolean,/fold_case) then coltype[i]='char'
  for j=0L,mi-1L do $
    if stregex(colname[i],string(idict[j]),/boolean,/fold_case) then $
    coltype[i]='integer'
  for j=0L,mf-1L do $
    if stregex(colname[i],string(fdict[j]),/boolean,/fold_case) then $
    coltype[i]='float'
  for j=0L,ml-1L do $
    if stregex(colname[i],string(ldict[j]),/boolean,/fold_case) then $
    coltype[i]='long'
  for j=0L,ms-1L do $
    if stregex(colname[i],string(sdict[j]),/boolean,/fold_case) then $
    coltype[i]='char'
endfor						;I=0,NFLDS-1}

;	make template structure a la ASCII_TEMPLATE()
icoltypes=intarr(nflds)+7
for i=0L,nflds-1L do begin
  if coltype[i] eq 'byte' then icoltypes[i]=1 else $
   if coltype[i] eq 'integer' then icoltypes[i]=2 else $
    if coltype[i] eq 'long' then icoltypes[i]=3 else $
     if coltype[i] eq 'float' then icoltypes[i]=4 else $
      if coltype[i] eq 'double' then icoltypes[i]=5
endfor
collocation=lonarr(nflds)-1L
delimiter=byte(ss)
if n_elements(delimiter) gt 0 then delimiter=byte(' ')
templat=create_struct('VERSION',1.0,$
	'DATASTART',0,$
	'DELIMITER',delimiter,$
	'MISSINGVALUE',!values.f_nan,$
	'COMMENTSYMBOL','#',$
	'FIELDCOUNT',nflds,$
	'FIELDTYPES',icoltypes,$
	'FIELDNAMES',colname,$
	'FIELDLOCATIONS',collocation,$
	'FIELDGROUPS',lindgen(nflds))

return
end
