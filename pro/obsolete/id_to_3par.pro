pro id_to_3par,id,x,pardir=pardir,root=root,tieion=tieion,tieID=tieID, _extra=e
;+
;procedure	id_to_3par
;	procedure to convert ID info from LINEID to gaussian shaped
;	line info for fitting and to write said info into appropriate
;	parameter files.
;
;parameters
;	id	[INPUT; required] structure containing all the ID
;		information, the output of LINEID
;	x	[INPUT] range of interest
;		* if 2-element array, represents the min,max
;		* if >2, min and max are determined "in situ"
;		* if <2, the whole info in ID is written out
;
;keywords
;	pardir	[INPUT; default: "/tmp"] directory in which to write
;		parameter files
;	root	[INPUT; default: "id"] prefix for parameter files
;	tieion	[INPUT] if set, forces offsets to be constant for lines
;		generated by same ions.
;	tieID	[INPUT] if set, forces offsets to be constant for multiple
;		IDs of single lines.  overrides TIEION.
;	_extra	[INPUT] junk -- here only to prevent crashing the program
;
;restrictions
;	requires LINEID to have been run first!
;
;history
;	vinay kashyap (Jun97)
;	now default is to take the range from the abs(ID.(*).wvl) (VK; Jul97)
;-

message,'OBSOLETE!',/informational

;	usage
np=n_tags(id)
if np eq 0 then begin
  print,'Usage: id_to_3pars,id,x,pardir=pardir,root=root,/tieion,/tieID'
  print,'  writes ID info to appropriate parameter files'
  return
endif

;	catch errors in input
idnam=tag_names(id)
if idnam(0) ne 'WVL' then begin
  message,'ID structure incorrect!',/info & return
endif

;	unpack ID structure
wvl=id.wvl & nw=n_elements(wvl)
ww=[0.] & zz=[0] & ion=[0] & flx=[0.]
grpdef=[0L] & grpid=[0L] & grpion=[0L] & grppt=-1L
for iw=0,nw-1 do begin
  w=(id.(iw+1).wvl) & Z=(id.(iw+1).Z) & jon=(id.(iw+1).ion) & f=(id.(iw+1).flux)
  n0=n_elements(w) & ww=[ww,w] & zz=[zz,Z] & ion=[ion,jon] & flx=[flx,f]
  grpdef=[grpdef,grppt+lindgen(n0)+1] & grppt=grppt+n0+1
  grpid=[grpid,lonarr(n0)+iw]
endfor
ww=ww(1:*) & zz=zz(1:*) & ion=ion(1:*) & flx=flx(1:*)
grpdef=grpdef(1:*) & grpid=grpid(1:*)

;	get range
nx=n_elements(x)
if nx ge 2 then begin
  xmin=min(x,max=xmax)
endif else begin
  xmin=min(abs(ww),max=xmax)
endelse

;	select only those wavelengths that lie within range
ow=where(abs(ww) ge xmin and abs(ww) le xmax,mow)
if mow eq 0 then begin
  message,'no lines selected!',/info & return
endif
ww=ww(ow) & zz=zz(ow) & ion=ion(ow) & flx=flx(ow)
grpdef=grpdef(ow) & grpid=grpid(ow)

;	any sort of grouping?
group=grpdef			;default: NONE
if keyword_set(tieion) then begin	;tie together lines of same ion
  zi=100*zz+ion & ii=zi(uniq(zi,sort(zi))) & ni=n_elements(ii)
  grpion=0*grpdef
  for i=0,ni-1 do begin
    oo=where(zi eq ii(i)) & grpion(oo)=i
  endfor
  group=grpion
endif
if keyword_set(tieID) then group=grpid

;	figure out best sigma
sig1=(xmax-xmin)/2.				;first guess
sig2=sqrt((moment(wvl))(1)) < sig1		;second guess
gg=grpid(uniq(grpid,sort(grpid))) & ng=n_elements(gg)
sig3=0.						;third guess
for i=0,ng-1 do begin
  oo=where(grpid eq gg,moo) & sig=sig3
  if moo gt 1 then sig=max(ww(oo))-min(ww(oo))
  if sig gt sig3 then sig3=sig
endfor
sigma=min([sig1,sig2,sig3])			;best guess

;	figure out output filenames
if not keyword_set(pardir) then pardir='/tmp'
if not keyword_set(root) then root='id'
pfile=pardir+'/'+root+'_pos.par' 
wfile=pardir+'/'+root+'_wdt.par' 
hfile=pardir+'/'+root+'_hgt.par' 
openw,upf,pfile,/get_lun
openw,uwf,wfile,/get_lun
openw,uhf,hfile,/get_lun

;	figure out how many unique groups
grp=group(uniq(group,sort(group))) & ngrp=n_elements(grp)

;	for each group, collect and write out
for i=0,ngrp-1 do begin
  oo=where(group eq grp(i),moo)
  pg=ww(oo) & wg=sigma+fltarr(moo) & hg=flx(oo) & dp=pg-pg(0)
  cp='' & cw='' & ch=''
  for j=0,moo-1 do begin
    if j gt 0 then pg(j)=dp(j)
    cp=cp+' '+strtrim(pg(j),2)
    cw=cw+' '+strtrim(wg(j),2)
    ch=ch+' '+strtrim(hg(j),2)
  endfor
  print,strtrim(cp,2)
  printf,upf,strtrim(cp,2)
  printf,uwf,strtrim(cw,2)
  printf,uhf,strtrim(ch,2)
endfor

;close output files
close,upf & free_lun,upf
close,uwf & free_lun,uwf
close,uhf & free_lun,uhf

return
end
